# ТЕХНИЧЕСКОЕ ЗАДАНИЕ: Telegram Bot для финансового учета

## 📁 СТРУКТУРА ПРОЕКТА

```
telegram_finance_bot/
├── requirements.txt
├── .env.example
├── .env
├── .gitignore
├── Dockerfile
├── docker-compose.yml
├── README.md
├── main.py
├── config.py
├── bot/
│   ├── __init__.py
│   ├── create_bot.py
│   ├── handlers/
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── expenses.py
│   │   ├── status.py
│   │   ├── instructions.py
│   │   └── common.py
│   ├── middlewares/
│   │   ├── __init__.py
│   │   └── auth.py
│   ├── keyboards/
│   │   ├── __init__.py
│   │   └── inline.py
│   └── states/
│       ├── __init__.py
│       └── expense.py
├── database/
│   ├── __init__.py
│   ├── models.py
│   ├── database.py
│   └── crud.py
├── services/
│   ├── __init__.py
│   ├── google_sheets.py
│   ├── scheduler.py
│   └── notifications.py
├── utils/
│   ├── __init__.py
│   └── helpers.py
└── data/
    ├── bot.db
    └── credentials.json
```

## 📦 requirements.txt

```txt
aiogram==3.10.0
sqlalchemy==2.0.23
aiosqlite==0.19.0
apscheduler==3.10.4
gspread==5.12.4
oauth2client==4.1.3
python-dotenv==1.0.0
pytz==2023.3
asyncio-mqtt==0.16.1
```

## ⚙️ .env.example

```env
# Telegram Bot Token (получить у @BotFather)
BOT_TOKEN=your_bot_token_here

# Google Sheets ID (из URL таблицы)
GOOGLE_SHEETS_ID=your_google_sheets_id_here

# Часовой пояс
TIMEZONE=Asia/Bishkek

# Время ежедневных напоминаний
REMINDER_TIME=20:00

# Коды авторизации для 3 пользователей
AUTH_CODE_USER1=SECURE_CODE_123
AUTH_CODE_USER2=SECURE_CODE_456  
AUTH_CODE_USER3=SECURE_CODE_789

# База данных
DATABASE_URL=sqlite+aiosqlite:///./data/bot.db

# Режим разработки
DEBUG=True
```

## 🗄️ config.py

```python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    GOOGLE_SHEETS_ID = os.getenv("GOOGLE_SHEETS_ID") 
    TIMEZONE = os.getenv("TIMEZONE", "Asia/Bishkek")
    REMINDER_TIME = os.getenv("REMINDER_TIME", "20:00")
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./data/bot.db")
    DEBUG = os.getenv("DEBUG", "False").lower() == "true"
    
    # Коды авторизации
    AUTH_CODES = {
        os.getenv("AUTH_CODE_USER1"): "Пользователь 1",
        os.getenv("AUTH_CODE_USER2"): "Пользователь 2", 
        os.getenv("AUTH_CODE_USER3"): "Пользователь 3"
    }
    
    # Google Credentials путь
    GOOGLE_CREDENTIALS = "./data/credentials.json"

config = Config()
```

## 🗃️ database/models.py

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Decimal, ForeignKey, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    telegram_id = Column(Integer, unique=True, index=True)
    username = Column(String, nullable=True)
    full_name = Column(String, nullable=False)
    is_authorized = Column(Boolean, default=False)
    auth_code = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_expense_date = Column(DateTime, nullable=True)
    
    # Связь с расходами
    expenses = relationship("Expense", back_populates="user")

class Expense(Base):
    __tablename__ = "expenses"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    amount = Column(Decimal(precision=10, scale=2), nullable=False)
    purpose = Column(Text, nullable=False)
    expense_date = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Связь с пользователем
    user = relationship("User", back_populates="expenses")

class DailyReminder(Base):
    __tablename__ = "daily_reminders"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    reminder_date = Column(DateTime, nullable=False)
    is_completed = Column(Boolean, default=False)
    reminder_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
```

## 🔗 database/database.py

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from config import config
from database.models import Base

# Создание движка базы данных
engine = create_async_engine(
    config.DATABASE_URL,
    echo=config.DEBUG
)

# Создание сессий
AsyncSessionLocal = async_sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)

async def create_tables():
    """Создание всех таблиц в базе данных"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def get_async_session():
    """Получение асинхронной сессии базы данных"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()
```

## 💾 database/crud.py

```python
from sqlalchemy import select, and_, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from database.models import User, Expense, DailyReminder
from datetime import datetime, date
from typing import Optional, List

class UserCRUD:
    @staticmethod
    async def get_user_by_telegram_id(db: AsyncSession, telegram_id: int) -> Optional[User]:
        result = await db.execute(select(User).where(User.telegram_id == telegram_id))
        return result.scalar_one_or_none()
    
    @staticmethod
    async def create_user(db: AsyncSession, telegram_id: int, username: str, full_name: str, auth_code: str) -> User:
        user = User(
            telegram_id=telegram_id,
            username=username,
            full_name=full_name,
            auth_code=auth_code,
            is_authorized=True
        )
        db.add(user)
        await db.commit()
        await db.refresh(user)
        return user
    
    @staticmethod
    async def get_all_authorized_users(db: AsyncSession) -> List[User]:
        result = await db.execute(select(User).where(User.is_authorized == True))
        return result.scalars().all()

class ExpenseCRUD:
    @staticmethod
    async def create_expense(db: AsyncSession, user_id: int, amount: float, purpose: str) -> Expense:
        expense = Expense(
            user_id=user_id,
            amount=amount,
            purpose=purpose
        )
        db.add(expense)
        await db.commit()
        await db.refresh(expense)
        return expense
    
    @staticmethod
    async def get_user_expenses_by_date(db: AsyncSession, user_id: int, target_date: date) -> List[Expense]:
        start_datetime = datetime.combine(target_date, datetime.min.time())
        end_datetime = datetime.combine(target_date, datetime.max.time())
        
        result = await db.execute(
            select(Expense)
            .where(and_(
                Expense.user_id == user_id,
                Expense.expense_date >= start_datetime,
                Expense.expense_date <= end_datetime
            ))
        )
        return result.scalars().all()
    
    @staticmethod
    async def get_all_expenses_by_date(db: AsyncSession, target_date: date) -> List[Expense]:
        start_datetime = datetime.combine(target_date, datetime.min.time())
        end_datetime = datetime.combine(target_date, datetime.max.time())
        
        result = await db.execute(
            select(Expense)
            .options(selectinload(Expense.user))
            .where(and_(
                Expense.expense_date >= start_datetime,
                Expense.expense_date <= end_datetime
            ))
        )
        return result.scalars().all()

class ReminderCRUD:
    @staticmethod
    async def create_daily_reminder(db: AsyncSession, user_id: int, reminder_date: datetime) -> DailyReminder:
        reminder = DailyReminder(
            user_id=user_id,
            reminder_date=reminder_date
        )
        db.add(reminder)
        await db.commit()
        await db.refresh(reminder)
        return reminder
    
    @staticmethod
    async def get_pending_reminders(db: AsyncSession, target_date: date) -> List[DailyReminder]:
        start_datetime = datetime.combine(target_date, datetime.min.time())
        end_datetime = datetime.combine(target_date, datetime.max.time())
        
        result = await db.execute(
            select(DailyReminder)
            .options(selectinload(DailyReminder.user))
            .where(and_(
                DailyReminder.reminder_date >= start_datetime,
                DailyReminder.reminder_date <= end_datetime,
                DailyReminder.is_completed == False
            ))
        )
        return result.scalars().all()
    
    @staticmethod
    async def mark_reminder_completed(db: AsyncSession, reminder_id: int):
        result = await db.execute(select(DailyReminder).where(DailyReminder.id == reminder_id))
        reminder = result.scalar_one_or_none()
        if reminder:
            reminder.is_completed = True
            await db.commit()
```

## 🔐 bot/middlewares/auth.py

```python
from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery
from database.database import AsyncSessionLocal
from database.crud import UserCRUD

class AuthMiddleware(BaseMiddleware):
    """Middleware для проверки авторизации пользователя"""
    
    def __init__(self):
        super().__init__()
    
    async def __call__(
        self,
        handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],
        event: Message | CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        # Пропускаем команды авторизации и старта
        if isinstance(event, Message):
            if event.text and (event.text.startswith('/auth') or event.text.startswith('/start')):
                return await handler(event, data)
        
        # Проверяем авторизацию
        async with AsyncSessionLocal() as db:
            user = await UserCRUD.get_user_by_telegram_id(db, event.from_user.id)
            
            if not user or not user.is_authorized:
                await event.answer("❌ Вы не авторизованы. Используйте команду /auth [код]")
                return
            
            data['current_user'] = user
            return await handler(event, data)
```

## ⌨️ bot/keyboards/inline.py

```python
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def get_main_menu_keyboard() -> InlineKeyboardMarkup:
    """Главное меню бота"""
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="💰 Расход", callback_data="expense")],
        [InlineKeyboardButton(text="📊 Статус", callback_data="status")],
        [InlineKeyboardButton(text="📖 Инструкция", callback_data="instructions")],
    ])
    return keyboard

def get_confirmation_keyboard() -> InlineKeyboardMarkup:
    """Клавиатура подтверждения"""
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="✅ Да", callback_data="confirm_yes"),
            InlineKeyboardButton(text="❌ Отмена", callback_data="confirm_no")
        ]
    ])
    return keyboard

def get_expense_completed_keyboard() -> InlineKeyboardMarkup:
    """Клавиатура после добавления расхода"""
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🏠 Главное меню", callback_data="main_menu")],
        [InlineKeyboardButton(text="💰 Добавить еще расход", callback_data="expense")]
    ])
    return keyboard
```

## 📊 services/google_sheets.py

```python
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from config import config
from typing import List, Dict
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class GoogleSheetsService:
    def __init__(self):
        self.scope = [
            'https://spreadsheets.google.com/feeds',
            'https://www.googleapis.com/auth/drive'
        ]
        self.credentials = None
        self.client = None
        self.sheet = None
        self._initialize()
    
    def _initialize(self):
        """Инициализация подключения к Google Sheets"""
        try:
            self.credentials = ServiceAccountCredentials.from_json_keyfile_name(
                config.GOOGLE_CREDENTIALS, self.scope
            )
            self.client = gspread.authorize(self.credentials)
            self.sheet = self.client.open_by_key(config.GOOGLE_SHEETS_ID)
            logger.info("Google Sheets подключен успешно")
        except Exception as e:
            logger.error(f"Ошибка подключения к Google Sheets: {e}")
    
    async def add_expense_to_sheet(self, user_name: str, amount: float, purpose: str, expense_date: datetime):
        """Добавление расхода в таблицу"""
        try:
            # Получаем или создаем лист "Расходы"
            try:
                worksheet = self.sheet.worksheet("Расходы")
            except gspread.WorksheetNotFound:
                worksheet = self.sheet.add_worksheet(title="Расходы", rows="1000", cols="6")
                # Добавляем заголовки
                worksheet.append_row(["Дата", "Пользователь", "Сумма", "Цель", "Время записи"])
            
            # Добавляем новую строку
            row_data = [
                expense_date.strftime("%d.%m.%Y"),
                user_name,
                float(amount),
                purpose,
                expense_date.strftime("%d.%m.%Y %H:%M:%S")
            ]
            
            worksheet.append_row(row_data)
            logger.info(f"Расход добавлен в Google Sheets: {user_name} - {amount}")
            
        except Exception as e:
            logger.error(f"Ошибка добавления расхода в Google Sheets: {e}")
            raise
    
    async def get_status_data(self) -> Dict[str, any]:
        """Получение данных для статуса из таблицы"""
        try:
            # Получаем лист "Статус данные" 
            try:
                worksheet = self.sheet.worksheet("Статус данные")
            except gspread.WorksheetNotFound:
                # Создаем лист если не существует
                worksheet = self.sheet.add_worksheet(title="Статус данные", rows="10", cols="2")
                # Добавляем заголовки и начальные данные
                initial_data = [
                    ["Показатель", "Значение"],
                    ["Общий оборот", "0"],
                    ["Долги в рынке", "0"], 
                    ["Личные затраты", "0"],
                    ["Инвестиции в бизнес", "0"],
                    ["Оборот магазин 1", "0"],
                    ["Оборот магазин 2", "0"]
                ]
                for row in initial_data:
                    worksheet.append_row(row)
            
            # Получаем все данные
            all_values = worksheet.get_all_values()
            
            # Преобразуем в словарь (пропуская заголовок)
            status_data = {}
            for row in all_values[1:]:  # Пропускаем первую строку (заголовки)
                if len(row) >= 2:
                    key = row[0]
                    value = row[1]
                    try:
                        # Пытаемся преобразовать в число
                        status_data[key] = float(value) if value else 0.0
                    except ValueError:
                        status_data[key] = value
            
            return status_data
            
        except Exception as e:
            logger.error(f"Ошибка получения данных статуса: {e}")
            return {}

# Глобальный экземпляр сервиса
google_sheets_service = GoogleSheetsService()
```

## 🕐 services/scheduler.py

```python
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.triggers.interval import IntervalTrigger
from database.database import AsyncSessionLocal
from database.crud import UserCRUD, ReminderCRUD
from services.notifications import NotificationService
from config import config
import pytz
import logging
from datetime import datetime, date

logger = logging.getLogger(__name__)

class SchedulerService:
    def __init__(self, bot):
        self.scheduler = AsyncIOScheduler(timezone=pytz.timezone(config.TIMEZONE))
        self.bot = bot
        self.notification_service = NotificationService(bot)
    
    def start(self):
        """Запуск планировщика"""
        # Ежедневное напоминание в 20:00
        hour, minute = map(int, config.REMINDER_TIME.split(':'))
        
        self.scheduler.add_job(
            self._send_daily_reminders,
            CronTrigger(hour=hour, minute=minute, timezone=pytz.timezone(config.TIMEZONE)),
            id='daily_reminder',
            name='Ежедневное напоминание о расходах'
        )
        
        # Повторные напоминания каждый час после 20:00
        self.scheduler.add_job(
            self._send_hourly_reminders,
            CronTrigger(minute=0, timezone=pytz.timezone(config.TIMEZONE)),
            id='hourly_reminder', 
            name='Почасовые напоминания'
        )
        
        # Сброс напоминаний в полночь
        self.scheduler.add_job(
            self._reset_daily_reminders,
            CronTrigger(hour=0, minute=0, timezone=pytz.timezone(config.TIMEZONE)),
            id='reset_reminders',
            name='Сброс ежедневных напоминаний'
        )
        
        self.scheduler.start()
        logger.info("Планировщик запущен")
    
    async def _send_daily_reminders(self):
        """Отправка ежедневных напоминаний в 20:00"""
        logger.info("Отправка ежедневных напоминаний")
        
        async with AsyncSessionLocal() as db:
            users = await UserCRUD.get_all_authorized_users(db)
            
            for user in users:
                # Создаем напоминание в БД
                await ReminderCRUD.create_daily_reminder(db, user.id, datetime.now())
                
                # Отправляем уведомление
                await self.notification_service.send_daily_reminder(user.telegram_id)
    
    async def _send_hourly_reminders(self):
        """Отправка почасовых напоминаний для тех, кто не ответил"""
        current_hour = datetime.now(pytz.timezone(config.TIMEZONE)).hour
        
        # Отправляем повторные напоминания только после 20:00 и до 23:59
        if current_hour < 20:
            return
        
        logger.info("Отправка почасовых напоминаний")
        
        async with AsyncSessionLocal() as db:
            today = date.today()
            pending_reminders = await ReminderCRUD.get_pending_reminders(db, today)
            
            for reminder in pending_reminders:
                reminder.reminder_count += 1
                await db.commit()
                
                await self.notification_service.send_hourly_reminder(
                    reminder.user.telegram_id, 
                    reminder.reminder_count
                )
    
    async def _reset_daily_reminders(self):
        """Сброс напоминаний в полночь"""
        logger.info("Сброс ежедневных напоминаний")
        # Здесь можно добавить логику очистки старых напоминаний если нужно
    
    def stop(self):
        """Остановка планировщика"""
        self.scheduler.shutdown()
        logger.info("Планировщик остановлен")
```

## 📢 services/notifications.py

```python
from aiogram import Bot
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
import logging

logger = logging.getLogger(__name__)

class NotificationService:
    def __init__(self, bot: Bot):
        self.bot = bot
    
    async def send_daily_reminder(self, telegram_id: int):
        """Отправка ежедневного напоминания в 20:00"""
        try:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="💰 Добавить расход", callback_data="expense")],
                [InlineKeyboardButton(text="📊 Посмотреть статус", callback_data="status")]
            ])
            
            message = (
                "🕐 <b>Ежедневное напоминание</b>\n\n"
                "Пожалуйста, укажите ваши расходы за сегодня.\n"
                "Если расходов не было - нажмите на кнопку и укажите 0.\n\n"
                "📝 Это поможет вести точный учет финансов бизнеса."
            )
            
            await self.bot.send_message(
                chat_id=telegram_id,
                text=message,
                parse_mode="HTML",
                reply_markup=keyboard
            )
            
            logger.info(f"Ежедневное напоминание отправлено пользователю {telegram_id}")
            
        except Exception as e:
            logger.error(f"Ошибка отправки ежедневного напоминания пользователю {telegram_id}: {e}")
    
    async def send_hourly_reminder(self, telegram_id: int, reminder_count: int):
        """Отправка почасового напоминания"""
        try:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="💰 Добавить расход сейчас", callback_data="expense")]
            ])
            
            message = (
                f"⏰ <b>Напоминание #{reminder_count}</b>\n\n"
                "Вы еще не указали расходы за сегодня.\n"
                "Пожалуйста, внесите информацию о тратах.\n\n"
                "💡 Если расходов не было, укажите сумму 0."
            )
            
            await self.bot.send_message(
                chat_id=telegram_id,
                text=message,
                parse_mode="HTML", 
                reply_markup=keyboard
            )
            
            logger.info(f"Почасовое напоминание #{reminder_count} отправлено пользователю {telegram_id}")
            
        except Exception as e:
            logger.error(f"Ошибка отправки почасового напоминания пользователю {telegram_id}: {e}")
```

## 🏠 bot/handlers/common.py

```python
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery
from bot.keyboards.inline import get_main_menu_keyboard

router = Router()

@router.message(Command("start"))
async def start_handler(message: Message):
    """Обработчик команды /start"""
    welcome_text = (
        "👋 <b>Добро пожаловать в Финансового Бота!</b>\n\n"
        "🔐 Для начала работы вам необходимо авторизоваться.\n"
        "Используйте команду: <code>/auth ВАШ_КОД</code>\n\n"
        "📞 За получением кода обратитесь к администратору."
    )
    
    await message.answer(welcome_text, parse_mode="HTML")

@router.callback_query(F.data == "main_menu")
async def main_menu_callback(callback: CallbackQuery):
    """Возврат в главное меню"""
    menu_text = (
        "🏠 <b>Главное меню</b>\n\n"
        "Выберите действие:"
    )
    
    await callback.message.edit_text(
        menu_text,
        parse_mode="HTML",
        reply_markup=get_main_menu_keyboard()
    )
    await callback.answer()

@router.message()
async def show_main_menu(message: Message, current_user):
    """Показ главного меню для авторизованных пользователей"""
    menu_text = (
        f"👤 <b>{current_user.full_name}</b>\n"
        f"🏠 <b>Главное меню</b>\n\n"
        "Выберите действие:"
    )
    
    await message.answer(
        menu_text,
        parse_mode="HTML",
        reply_markup=get_main_menu_keyboard()
    )
```

## 🔐 bot/handlers/auth.py

```python
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message
from database.database import AsyncSessionLocal
from database.crud import UserCRUD
from config import config
import logging

logger = logging.getLogger(__name__)
router = Router()

@router.message(Command("auth"))
async def auth_handler(message: Message):
    """Обработчик авторизации"""
    try:
        # Проверяем формат команды
        command_parts = message.text.split()
        if len(command_parts) != 2:
            await message.answer(
                "❌ Неверный формат команды.\n"
                "Используйте: <code>/auth ВАШ_КОД</code>",
                parse_mode="HTML"
            )
            return
        
        auth_code = command_parts[1]
        
        # Проверяем код авторизации
        if auth_code not in config.AUTH_CODES:
            await message.answer("❌ Неверный код авторизации.")
            return
        
        # Получаем имя пользователя по коду
        user_name = config.AUTH_CODES[auth_code]
        
        async with AsyncSessionLocal() as db:
            # Проверяем, не авторизован ли уже пользователь
            existing_user = await UserCRUD.get_user_by_telegram_id(db, message.from_user.id)
            
            if existing_user and existing_user.is_authorized:
                await message.answer("✅ Вы уже авторизованы в системе.")
                return
            
            # Создаем нового пользователя или обновляем существующего
            if not existing_user:
                user = await UserCRUD.create_user(
                    db=db,
                    telegram_id=message.from_user.id,
                    username=message.from_user.username or "",
                    full_name=user_name,
                    auth_code=auth_code
                )
            else:
                existing_user.is_authorized = True
                existing_user.auth_code = auth_code
                existing_user.full_name = user_name
                await db.commit()
                user = existing_user
            
            success_text = (
                f"✅ <b>Авторизация успешна!</b>\n\n"
                f"👤 Добро пожаловать, <b>{user.full_name}</b>\n\n"
                f"🤖 Теперь вы можете пользоваться ботом.\n"
                f"Напишите любое сообщение для вызова главного меню."
            )
            
            await message.answer(success_text, parse_mode="HTML")
            logger.info(f"Пользователь {user.full_name} (ID: {message.from_user.id}) авторизован")
    
    except Exception as e:
        logger.error(f"Ошибка авторизации: {e}")
        await message.answer("❌ Произошла ошибка при авторизации. Попробуйте позже.")
```

## 🎯 bot/states/expense.py

```python
from aiogram.fsm.state import StatesGroup, State

class ExpenseForm(StatesGroup):
    waiting_amount = State()
    waiting_purpose = State()
    waiting_confirmation = State()
```

## 💰 bot/handlers/expenses.py

```python
from aiogram import Router, F
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery
from database.database import AsyncSessionLocal
from database.crud import ExpenseCRUD, ReminderCRUD
from services.google_sheets import google_sheets_service
from bot.states.expense import ExpenseForm
from bot.keyboards.inline import get_confirmation_keyboard, get_expense_completed_keyboard
from datetime import datetime, date
import logging

logger = logging.getLogger(__name__)
router = Router()

@router.callback_query(F.data == "expense")
async def start_expense_input(callback: CallbackQuery, state: FSMContext, current_user):
    """Начало процесса добавления расхода"""
    await state.set_state(ExpenseForm.waiting_amount)
    
    text = (
        f"💰 <b>Добавление расхода</b>\n\n"
        f"👤 Пользователь: <b>{current_user.full_name}</b>\n"
        f"📅 Дата: <b>{datetime.now().strftime('%d.%m.%Y')}</b>\n\n"
        f"💵 Введите сумму расхода (в сомах):\n"
        f"<i>Если расходов не было, введите 0</i>"
    )
    
    await callback.message.edit_text(text, parse_mode="HTML")
    await callback.answer()

@router.message(ExpenseForm.waiting_amount)
async def process_amount(message: Message, state: FSMContext, current_user):
    """Обработка суммы расхода"""
    try:
        amount = float(message.text.replace(',', '.'))
        if amount < 0:
            await message.answer("❌ Сумма не может быть отрицательной. Введите корректную сумму:")
            return
        
        await state.update_data(amount=amount)
        await state.set_state(ExpenseForm.waiting_purpose)
        
        if amount == 0:
            purpose_text = (
                "📝 <b>Укажите причину отсутствия расходов:</b>\n\n"
                "Например:\n"
                "• Выходной день\n"
                "• Не было операций\n"
                "• Работал удаленно"
            )
        else:
            purpose_text = (
                f"💰 Сумма: <b>{amount:,.2f} сом</b>\n\n"
                f"📝 <b>Укажите цель расхода:</b>\n\n"
                f"Например:\n"
                f"• Покупка товара для магазина\n"
                f"• Оплата поставщику\n"
                f"• Транспортные расходы\n"
                f"• Личные нужды"
            )
        
        await message.answer(purpose_text, parse_mode="HTML")
        
    except ValueError:
        await message.answer(
            "❌ Неверный формат суммы.\n"
            "Введите число (например: 1500 или 1500.50):"
        )

@router.message(ExpenseForm.waiting_purpose)
async def process_purpose(message: Message, state: FSMContext, current_user):
    """Обработка цели расхода"""
    purpose = message.text.strip()
    
    if not purpose:
        await message.answer("❌ Цель расхода не может быть пустой. Введите описание:")
        return
    
    if len(purpose) > 500:
        await message.answer("❌ Описание слишком длинное (максимум 500 символов). Сократите описание:")
        return
    
    data = await state.get_data()
    amount = data['amount']
    
    await state.update_data(purpose=purpose)
    await state.set_state(ExpenseForm.waiting_confirmation)
    
    # Формируем сообщение подтверждения
    confirmation_text = (
        f"📋 <b>Подтверждение расхода</b>\n\n"
        f"👤 <b>Пользователь:</b> {current_user.full_name}\n"
        f"📅 <b>Дата:</b> {datetime.now().strftime('%d.%m.%Y')}\n"
        f"💰 <b>Сумма:</b> {amount:,.2f} сом\n"
        f"📝 <b>Цель:</b> {purpose}\n\n"
        f"❓ Сохранить этот расход?"
    )
    
    await message.answer(
        confirmation_text,
        parse_mode="HTML",
        reply_markup=get_confirmation_keyboard()
    )

@router.callback_query(F.data == "confirm_yes", ExpenseForm.waiting_confirmation)
async def confirm_expense(callback: CallbackQuery, state: FSMContext, current_user):
    """Подтверждение и сохранение расхода"""
    try:
        data = await state.get_data()
        amount = data['amount']
        purpose = data['purpose']
        
        async with AsyncSessionLocal() as db:
            # Сохраняем расход в базу данных
            expense = await ExpenseCRUD.create_expense(
                db=db,
                user_id=current_user.id,
                amount=amount,
                purpose=purpose
            )
            
            # Сохраняем в Google Sheets
            await google_sheets_service.add_expense_to_sheet(
                user_name=current_user.full_name,
                amount=amount,
                purpose=purpose,
                expense_date=expense.created_at
            )
            
            # Отмечаем напоминание как выполненное
            today = date.today()
            pending_reminders = await ReminderCRUD.get_pending_reminders(db, today)
            for reminder in pending_reminders:
                if reminder.user_id == current_user.id:
                    await ReminderCRUD.mark_reminder_completed(db, reminder.id)
                    break
        
        success_text = (
            f"✅ <b>Расход успешно сохранен!</b>\n\n"
            f"📊 Данные добавлены в систему учета и Google Таблицу.\n\n"
            f"Что дальше?"
        )
        
        await callback.message.edit_text(
            success_text,
            parse_mode="HTML",
            reply_markup=get_expense_completed_keyboard()
        )
        await callback.answer("Расход сохранен!")
        await state.clear()
        
        logger.info(f"Расход сохранен: {current_user.full_name} - {amount} сом")
        
    except Exception as e:
        logger.error(f"Ошибка сохранения расхода: {e}")
        await callback.message.edit_text("❌ Произошла ошибка при сохранении. Попробуйте позже.")
        await callback.answer()
        await state.clear()

@router.callback_query(F.data == "confirm_no", ExpenseForm.waiting_confirmation)
async def cancel_expense(callback: CallbackQuery, state: FSMContext):
    """Отмена добавления расхода"""
    from bot.keyboards.inline import get_main_menu_keyboard
    
    await callback.message.edit_text(
        "❌ Добавление расхода отменено.\n\n🏠 Возвращаемся в главное меню:",
        reply_markup=get_main_menu_keyboard()
    )
    await callback.answer("Отменено")
    await state.clear()
```

## 📊 bot/handlers/status.py

```python
from aiogram import Router, F
from aiogram.types import CallbackQuery
from services.google_sheets import google_sheets_service
from bot.keyboards.inline import get_main_menu_keyboard
import logging

logger = logging.getLogger(__name__)
router = Router()

@router.callback_query(F.data == "status")
async def show_status(callback: CallbackQuery, current_user):
    """Показать статус финансов"""
    try:
        # Получаем данные из Google Sheets
        status_data = await google_sheets_service.get_status_data()
        
        if not status_data:
            await callback.message.edit_text(
                "❌ Не удалось получить данные статуса.\n"
                "Проверьте настройки Google Sheets.",
                reply_markup=get_main_menu_keyboard()
            )
            await callback.answer()
            return
        
        # Получаем значения или устанавливаем по умолчанию 0
        total_turnover = status_data.get('Общий оборот', 0)
        market_debt = status_data.get('Долги в рынке', 0)  
        personal_expenses = status_data.get('Личные затраты', 0)
        business_investment = status_data.get('Инвестиции в бизнес', 0)
        shop1_turnover = status_data.get('Оборот магазин 1', 0)
        shop2_turnover = status_data.get('Оборот магазин 2', 0)
        
        # Формируем сообщение статуса
        status_text = (
            f"📊 <b>Финансовый статус</b>\n"
            f"👤 Запросил: {current_user.full_name}\n\n"
            
            f"💰 <b>1. Общий оборот:</b>\n"
            f"   {total_turnover:,.2f} сом\n\n"
            
            f"🏪 <b>2. Долги в рынке:</b>\n" 
            f"   {market_debt:,.2f} сом\n\n"
            
            f"👤 <b>3. Личные затраты:</b>\n"
            f"   {personal_expenses:,.2f} сом\n\n"
            
            f"📈 <b>4. Инвестиции в бизнес:</b>\n"
            f"   {business_investment:,.2f} сом\n\n"
            
            f"🏬 <b>5. Оборот по магазинам:</b>\n"
            f"   • Магазин 1: {shop1_turnover:,.2f} сом\n"
            f"   • Магазин 2: {shop2_turnover:,.2f} сом\n\n"
            
            f"📋 <b>Общие суммы:</b>\n"
            f"• Всего оборот: {total_turnover:,.2f} сом\n"
            f"• Всего долгов: {market_debt:,.2f} сом\n\n"
            
            f"🕐 <i>Данные обновлены: {status_data.get('last_updated', 'неизвестно')}</i>"
        )
        
        keyboard = get_main_menu_keyboard()
        
        await callback.message.edit_text(
            status_text,
            parse_mode="HTML",
            reply_markup=keyboard
        )
        await callback.answer()
        
        logger.info(f"Статус запрошен пользователем {current_user.full_name}")
        
    except Exception as e:
        logger.error(f"Ошибка получения статуса: {e}")
        await callback.message.edit_text(
            "❌ Произошла ошибка при получении статуса.\n"
            "Попробуйте позже или обратитесь к администратору.",
            reply_markup=get_main_menu_keyboard()
        )
        await callback.answer()
```

## 📖 bot/handlers/instructions.py

```python
from aiogram import Router, F
from aiogram.types import CallbackQuery
from bot.keyboards.inline import get_main_menu_keyboard

router = Router()

@router.callback_query(F.data == "instructions")
async def show_instructions(callback: CallbackQuery, current_user):
    """Показать инструкцию по использованию бота"""
    
    instructions_text = (
        f"📖 <b>Инструкция по использованию</b>\n"
        f"👤 Пользователь: {current_user.full_name}\n\n"
        
        f"🤖 <b>О боте:</b>\n"
        f"Этот бот предназначен для учета бизнес-расходов команды из 3 человек. "
        f"Он автоматически напоминает о необходимости внести данные о тратах и "
        f"ведет учет в Google Таблицах.\n\n"
        
        f"🔐 <b>1. Авторизация</b>\n"
        f"• Используйте команду: <code>/auth ВАШ_КОД</code>\n"
        f"• Код предоставляет администратор\n"
        f"• После авторизации у вас есть доступ ко всем функциям\n\n"
        
        f"💰 <b>2. Команда 'Расход'</b>\n"
        f"• Нажмите кнопку 'Расход' в главном меню\n"
        f"• Введите сумму (если расходов не было, введите 0)\n"
        f"• Укажите цель или причину расхода\n"
        f"• Подтвердите сохранение\n"
        f"• Данные автоматически сохранятся в Google Таблицу\n\n"
        
        f"📊 <b>3. Команда 'Статус'</b>\n"
        f"Показывает актуальную финансовую информацию:\n"
        f"• Общий оборот бизнеса\n"
        f"• Долги в рынке (оптовые закупки в долг)\n" 
        f"• Личные затраты сотрудников\n"
        f"• Инвестиции в развитие бизнеса\n"
        f"• Отдельный оборот по каждому магазину\n\n"
        
        f"🕐 <b>4. Система напоминаний</b>\n"
        f"• В 20:00 каждый день приходит напоминание\n"
        f"• Если не внести данные, бот будет напоминать каждый час\n"
        f"• Напоминания прекращаются после внесения информации\n"
        f"• В полночь цикл начинается заново\n\n"
        
        f"📋 <b>5. Google Таблицы</b>\n"
        f"• Все расходы автоматически записываются в таблицу\n"
        f"• Данные для статуса берутся из отдельного листа\n"
        f"• Администратор может обновлять данные вручную\n\n"
        
        f"❓ <b>Часто задаваемые вопросы:</b>\n\n"
        f"<b>Q:</b> Что делать, если расходов не было?\n"
        f"<b>A:</b> Введите сумму 0 и укажите причину (выходной, нет операций и т.д.)\n\n"
        
        f"<b>Q:</b> Можно ли исправить ошибку в записи?\n"
        f"<b>A:</b> Обратитесь к администратору для корректировки в Google Таблице\n\n"
        
        f"<b>Q:</b> Не приходят напоминания, что делать?\n"
        f"<b>A:</b> Проверьте, авторизованы ли вы, или обратитесь к администратору\n\n"
        
        f"📞 <b>Поддержка:</b>\n"
        f"При возникновении проблем обращайтесь к администратору системы.\n\n"
        
        f"✅ <b>Советы для эффективного использования:</b>\n"
        f"• Вносите данные сразу после трат\n"
        f"• Будьте точны в описании целей расходов\n"
        f"• Не игнорируйте ежедневные напоминания\n"
        f"• Регулярно проверяйте статус для контроля финансов"
    )
    
    await callback.message.edit_text(
        instructions_text,
        parse_mode="HTML",
        reply_markup=get_main_menu_keyboard()
    )
    await callback.answer()
```

## 🤖 bot/create_bot.py

```python
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from config import config
from bot.middlewares.auth import AuthMiddleware
from bot.handlers import auth, common, expenses, status, instructions

def create_bot() -> tuple[Bot, Dispatcher]:
    """Создание экземпляра бота и диспетчера"""
    
    # Создаем бота
    bot = Bot(
        token=config.BOT_TOKEN,
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    
    # Создаем диспетчер
    dp = Dispatcher()
    
    # Регистрируем middleware (авторизация НЕ для auth и start команд)
    auth_middleware = AuthMiddleware()
    
    # Регистрируем роутеры
    dp.include_router(auth.router)      # Авторизация (без middleware)
    
    # Остальные роутеры с middleware
    expenses.router.message.middleware(auth_middleware)
    expenses.router.callback_query.middleware(auth_middleware)
    
    status.router.callback_query.middleware(auth_middleware)
    instructions.router.callback_query.middleware(auth_middleware)
    common.router.message.middleware(auth_middleware)
    common.router.callback_query.middleware(auth_middleware)
    
    dp.include_router(expenses.router)
    dp.include_router(status.router)  
    dp.include_router(instructions.router)
    dp.include_router(common.router)    # В конце, как fallback
    
    return bot, dp
```

## 🚀 main.py

```python
import asyncio
import logging
import sys
from bot.create_bot import create_bot
from database.database import create_tables
from services.scheduler import SchedulerService

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger(__name__)

async def main():
    """Главная функция запуска бота"""
    logger.info("Запуск Telegram бота...")
    
    try:
        # Создаем таблицы в базе данных
        await create_tables()
        logger.info("База данных инициализирована")
        
        # Создаем бота и диспетчер
        bot, dp = create_bot()
        logger.info("Бот создан")
        
        # Создаем и запускаем планировщик
        scheduler = SchedulerService(bot)
        scheduler.start()
        logger.info("Планировщик запущен")
        
        # Запускаем polling
        logger.info("Бот запущен и готов к работе!")
        await dp.start_polling(bot)
        
    except Exception as e:
        logger.error(f"Критическая ошибка: {e}")
    finally:
        # Остановка планировщика при завершении
        if 'scheduler' in locals():
            scheduler.stop()
        logger.info("Бот остановлен")

if __name__ == "__main__":
    asyncio.run(main())
```

## 🗂️ utils/helpers.py

```python
from datetime import datetime
import re

def format_amount(amount: float) -> str:
    """Форматирование суммы с разделителями тысяч"""
    return f"{amount:,.2f}".replace(",", " ")

def validate_amount(amount_str: str) -> tuple[bool, float]:
    """Валидация и парсинг суммы"""
    try:
        # Заменяем запятую на точку
        amount_str = amount_str.replace(",", ".")
        
        # Удаляем пробелы
        amount_str = re.sub(r'\s', '', amount_str)
        
        # Парсим число
        amount = float(amount_str)
        
        # Проверяем диапазон
        if amount < 0:
            return False, 0.0
        
        if amount > 10000000:  # 10 млн сом максимум
            return False, 0.0
        
        return True, amount
        
    except ValueError:
        return False, 0.0

def format_datetime_kg(dt: datetime) -> str:
    """Форматирование даты и времени для Кыргызстана"""
    months = [
        "января", "февраля", "марта", "апреля", "мая", "июня",
        "июля", "августа", "сентября", "октября", "ноября", "декабря"
    ]
    
    day = dt.day
    month = months[dt.month - 1]
    year = dt.year
    time = dt.strftime("%H:%M")
    
    return f"{day} {month} {year} г. в {time}"
```

## 📄 .gitignore

```gitignore
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Environment variables
.env
.env.local
.env.production

# Database
*.db
*.sqlite3
data/bot.db

# Google Credentials
data/credentials.json
credentials.json

# Logs
*.log
logs/

# Virtual environment
venv/
env/
.venv/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Temporary files
*.tmp
*.temp
```

## 🐳 Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Установка системных зависимостей
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Копирование файлов требований и установка зависимостей
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Копирование кода приложения
COPY . .

# Создание директории для данных
RUN mkdir -p data

# Установка переменных среды
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# Команда запуска
CMD ["python", "main.py"]
```

## 🔧 docker-compose.yml

```yaml
version: '3.8'

services:
  telegram-bot:
    build: .
    container_name: finance_telegram_bot
    restart: unless-stopped
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    environment:
      - BOT_TOKEN=${BOT_TOKEN}
      - GOOGLE_SHEETS_ID=${GOOGLE_SHEETS_ID}
      - TIMEZONE=Asia/Bishkek
      - REMINDER_TIME=20:00
      - AUTH_CODE_USER1=${AUTH_CODE_USER1}
      - AUTH_CODE_USER2=${AUTH_CODE_USER2}
      - AUTH_CODE_USER3=${AUTH_CODE_USER3}
      - DATABASE_URL=sqlite+aiosqlite:///./data/bot.db
      - DEBUG=False
    depends_on:
      - db
    networks:
      - bot-network

  db:
    image: postgres:15-alpine
    container_name: finance_bot_db
    restart: unless-stopped
    environment:
      POSTGRES_DB: finance_bot
      POSTGRES_USER: ${DB_USER:-botuser}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-securepassword123}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - bot-network
    ports:
      - "5432:5432"

volumes:
  postgres_data:

networks:
  bot-network:
    driver: bridge
```

## 📋 README.md

```markdown
# 💰 Finance Telegram Bot

Telegram бот для учета бизнес-расходов команды с интеграцией Google Sheets и автоматическими напоминаниями.

## 🚀 Возможности

- ✅ Авторизация по уникальным кодам
- 💰 Удобное добавление расходов через интерактивный интерфейс
- 📊 Просмотр финансового статуса в реальном времени
- 🔄 Автоматическая синхронизация с Google Sheets
- ⏰ Ежедневные напоминания в 20:00 по Кыргызскому времени
- 📢 Почасовые повторные напоминания до внесения данных
- 📖 Подробная инструкция по использованию

## 🛠 Установка и настройка

### 1. Клонирование репозитория
\`\`\`bash
git clone <repository-url>
cd telegram_finance_bot
\`\`\`

### 2. Установка зависимостей
\`\`\`bash
pip install -r requirements.txt
\`\`\`

### 3. Настройка окружения
Скопируйте `.env.example` в `.env` и заполните переменные:

\`\`\`bash
cp .env.example .env
\`\`\`

### 4. Настройка Telegram бота
1. Создайте бота через @BotFather
2. Получите токен и добавьте в `.env`

### 5. Настройка Google Sheets API
1. Создайте проект в Google Cloud Console
2. Включите Google Sheets API
3. Создайте Service Account
4. Скачайте credentials.json в папку `data/`
5. Создайте Google Таблицу и дайте доступ Service Account
6. Добавьте ID таблицы в `.env`

### 6. Запуск
\`\`\`bash
python main.py
\`\`\`

## 🐳 Docker

\`\`\`bash
docker-compose up -d
\`\`\`

## 📊 Структура Google Sheets

### Лист "Расходы" (автоматически заполняется)
| Дата | Пользователь | Сумма | Цель | Время записи |

### Лист "Статус данные" (заполняется вручную)
| Показатель | Значение |
|------------|----------|
| Общий оборот | 0 |
| Долги в рынке | 0 |
| Личные затраты | 0 |
| Инвестиции в бизнес | 0 |
| Оборот магазин 1 | 0 |
| Оборот магазин 2 | 0 |

## 👥 Команды бота

- `/start` - Приветствие и информация
- `/auth [код]` - Авторизация пользователя
- `💰 Расход` - Добавление нового расхода
- `📊 Статус` - Просмотр финансового статуса
- `📖 Инструкция` - Подробная инструкция

## 🔧 Техническая информация

- **Python**: 3.11+
- **Framework**: aiogram 3.x
- **Database**: SQLite/PostgreSQL
- **Scheduler**: APScheduler
- **Timezone**: Asia/Bishkek

## 📞 Поддержка

При возникновении вопросов или проблем обращайтесь к администратору системы.
\`\`\`

---

## 🎯 ИНСТРУКЦИИ ПО РАЗВЕРТЫВАНИЮ

### 1. Получение Telegram Bot Token:
1. Найдите @BotFather в Telegram
2. Отправьте `/newbot`
3. Следуйте инструкциям
4. Сохраните полученный токен

### 2. Настройка Google Sheets:
1. Перейдите в [Google Cloud Console](https://console.cloud.google.com/)
2. Создайте новый проект
3. Включите Google Sheets API
4. Создайте Service Account
5. Скачайте JSON ключ
6. Создайте Google Таблицу
7. Дайте доступ Service Account (по email из JSON)
8. Скопируйте ID таблицы из URL

### 3. Генерация кодов авторизации:
Используйте безопасные уникальные коды для каждого пользователя:
- USER1: `SECURE_CODE_123`
- USER2: `SECURE_CODE_456`  
- USER3: `SECURE_CODE_789`

### 4. Первый запуск:
1. Заполните все переменные в `.env`
2. Поместите `credentials.json` в папку `data/`
3. Запустите бота: `python main.py`
4. Проверьте логи на ошибки
5. Авторизуйтесь: `/auth ВАШ_КОД`

### 5. Настройка уведомлений:
Бот автоматически будет отправлять напоминания в 20:00 по Кыргызскому времени.

---

## ✅ ЧЕКЛИСТ ДЛЯ CLAUDE CODE

- [ ] Создать всю структуру проекта
- [ ] Установить все зависимости из requirements.txt
- [ ] Создать все файлы согласно техническому заданию
- [ ] Настроить базу данных и модели
- [ ] Реализовать все handlers (auth, expenses, status, instructions)
- [ ] Настроить middleware авторизации
- [ ] Интегрировать Google Sheets API
- [ ] Реализовать планировщик уведомлений
- [ ] Создать Docker файлы
- [ ] Написать README с инструкциями
- [ ] Протестировать основной функционал

**Проект готов к разработке в Claude Code!**